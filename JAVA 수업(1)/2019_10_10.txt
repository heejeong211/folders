*금요일 시험

프리미티브 타입, 크기

길이를 재는 함수

클래스 함수와 인스턴스 함수 차이
클래스 함수는 객체가 있거나 없거나 상관없이 사용할 수 있고,
인스턴스 함수는 무조건 객체를 만들어 줘야만 사용할 수 있다.

16진수를 정수로 코드 짜기

1~100까지 3이 들어가는 모든 숫자 다 출력되는 코드 짜기

--------------------------------------------------

// File Name? HelloWorld
// [public/ private/ protected] class <class_name> 패키지 밖에서 

public class HelloWorld {
      //  class method (static member method)
         public static void main(String[] args) {
              System.out.println("Hello World");
    }
}
// instance method (member method)
public void main() {
}

------------------------------------------------

interface Printng {
      void print();
}

추상화 함수와 비슷함.
------------------------------------------------

*시험!!!!!!!

1. 클래스 와 객체의 차이점
클래스는 사용자 타입, 어떤 문제를 모델링할 때 혹은 타입을 제정할 때 클래스를 사용함.
객체는 어떤 클래스가 인스턴스화 된 것이 객체임.

2. 추상화 클래스란?
추상화 함수를 하나라도 같고 있다면 추상화 클래스라고 정의한다.

2-1. 추상화 함수는 ?
클래스에 함수를 선언 하였으나 함수의 정의가 없거나 함수를 구현하지 않으면 추상화 함수라고 한다.

3. 상속이란?
상속에는 두가지가 있다 구현상속과 인터페이스 상속이 있다 
구현상속은 부모클래스에게 구현된 정의를 구현하는 것
인터페이스 상속은 부모클래스에서 인터페이스의 함수들의 선언을 상속 받는 것 

4. 인터페이스는 무엇인가?
추상화 클래스의 추상화 함수와 같이 함수의 선언만 포함되고 있는 것을 인터페이스라고 한다.

5. 함수의 재정의는 무엇인가?(오버라이딩)
부모클래스와 같은 시그네이쳐를 갖는 함수를 통하여 부모의 함수의 기능을 물려받는 것이
메소드의 오버라이딩이라고 한다.
함수 재정의를 통해 객체지향언어의 다형성을 구현한다.

6. 함수의 중첩은 무엇인가?(오버로딩)
같은 이름을 가졌으나 함수의 인자 또는 순서, 타입이 다른 것을 
여러개로 정의한 것을 말한다.(시그네이쳐가 다름)

7. 상수형 함수란 무엇인가?
재정의 할 수 없는 함수를 의미한다. (오버라이딩 안됨.)

8. this 객체는 무엇인가?
인스턴스 함수 안에서 현재 객체를 지칭할 때를 말하는 것이다.
클래스 메소드에서는 사용불가 

9. super는 무엇인가?
재정의가 되어있을 때, 부모 객체 부분의 함수의 이름이 같을 때
인스턴스 메소드에서 상속받은 부모 객체 부분을 접근할 때 사용된다.
현재 객체의 부모 객체 부분을 말한다. 


* 추상화 클래스와 인터페이스 차이점
둘 다 함수의 선언만 있지 정의나 구현이 되어있지 않다
그러나 인터페이스에서는 구현상속을 사용할 수 없으므로 구현상속을
사용할 때에는 추상화 클래스를 이용해야 한다.

(요오오오오오즘 인터페이스에서도 디폴트 메소드(함수)가 생기면서 
구현상속이 가능해졌다...... )
-------------------------------------------------------

 1. 논리연산자의 종류를 나열하시오.
논리연산자 &&, ex) A && B 
논리연산자 || ex ) A || B
논리연산자 ! (반환연산자) ex) !A

=> A와 B는 boolean식 또는 변수여야 한다. 
    
2. 비교(관계)연산자의 종류를 나열하시오. 
 ==
 != 
 <
 <=
 >
 >=

3. 산술연산자의 종류를 나열하시오.
 *
 /  나누기 연산자
 % 나머지 연산자
 +
 -
*나머지 연산자는 실수 사용 안함. 무조건 정수만 
또한 5%2 하면 2 나옴 반올림 안함.

4. 비트연산자의 종류를 나열하시오.
 & 비트 AND 연산자
 | 
 ^ 비트 XOR 연산자
 ~ 

5. 시프트 연산자
 >> 오른쪽 시프트, 2로 나눈 거와 같음
 << 왼쪽 시프트, 2로 곱한거와 같음

6. assignment((할당) 연산자
 =
 *=, ex) a*=(b+1) => a= a*(b+1) 우선수위 오른쪽. 먼저임 곱하기가 와도
 +=
 /=
 %=

*산술, 비트, 시프트 연산자 할당 연산자에 다 옴
결합법칙, 교환법칙 되는데 이항연산자는 교환법칙은 안됨.
또한 논리연산자는 제일 많은 상황을 왼쪽에 넣어야 함. 
따라서 교환법칙이 되긴 되는데 주의해야함.


-------------------------------------

1. **********Call by value VS Call by reference***********

함수의 인자에 프리미티브 타입(new안쓰는) 쓰면 콜 바이 벨뉴임.
인수의 타입이 프리미티브라면 콜 바이 벨뉴
값이 전달(복사). 객체가 전달
=====================================
함수의 인자에 스트링이나 클래스 타입을 쓰면 콜 바이 레퍼런스임.
인수의 타입이 클래스타입 이라면 콜 바이 레퍼런스
컨텐츠를 바꾸는 거임. 객체를 바꾸는 것이 아니라. 왜냐하면 로컬변수에서 일어나기 때문.
new 사용하면 콜 바이 레퍼런스임(new 는 힙에 저장되니까)
값이 복사되는 게 아니라 참조(값의 주소)하는 것이다.