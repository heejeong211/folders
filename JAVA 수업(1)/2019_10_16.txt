객체를 만들기 위해서는 new로 해주는 수 밖에 없다.
static은 클래스 메소드 그렇기 때문에 this 사용하지 못하면 인스턴스 메소드도 호출 못함.
객체에서는 static 메소드를 접근할 수 있지만 반대는 안됨.
클래스 메소드에서는 인스턴스 호출 못함.

-------------------------------------------------------------

아토믹하다: 더 이상 쪼갤 수 없다. 그 일은 무조건 실행함 다른 애들이 방해 못함 그러나 코딩에서는 
아토믹하지는 않다.
동기화: 경쟁하는 상태에서 줄을 세우는거. synchronized를 안쓰면 이상하게 됨.
인스턴스를 하나만 생성할 수 있도록 구현하는 패턴
싱글 턴 패턴: 생성자의 인자가 필요하지 않을 때(디자인 패턴의 한 종류)

  private static Singleton sIstance = new Singleton(); //동적일때는 사용 안함.

  public static Singleton getInstance() {

  return sInstance;
}

메인으로 가져올 때는 new 사용하지 않음... 그냥 get.Instance라고 붙임.
-------------------------------------------------------------

*캘린더 클래스

-------------------------------------------------------------

public class Message {
 
      private String title;
      private String message;
      private Integer alertId;
      private Integer badgeCount;
}
를 게터셋터로 만들고

게터셋터 지우고
private Message() {
}

public static class Builder {
     private String title;
     private String message;
     private Integer alertId;
     private Integer badgeCount;

를 게터셋터로 만들고

public class Main { 

public static void main(String[] args) {

    Message message = new Message(); //파라미터가 너무 많을 때, 빌더 패턴을 사용해야함.
    message.setTitle("알림");
    message.setMessage("알림");
    message.setAlertId("알림");
    message.setBadgeCount("알림");
    


빌더 패턴을 사용하면 빌더에서만 작업해야 함....

-----------------------------------------------------------

***1. 클래스 메소드 vs 인스턴스 메소드 사용하기 (구분)

***2.싱글톤 패턴
   - 오직 하나의 인스턴스만을 가질 수 있는 클래스 디자인 패턴.
   - 싱글톤 패턴을 만드는 3가지 방법 (다중쓰레드 환경 고려)

3. 빌더 패턴
   - 인스턴스를 생성을 돕는 클래스 디자인 패턴 (인자가 많은 경우 도움이 된다) 
   - 정적 내부(Inner) 클래스를 사용하여 클래스의 인스턴스를 생성하는 방법.

------------------------------------------------------

1. 무엇을 디자인 할 것인가?
문제를 파악하고...
계산기...0을 누르면 숫자 0이 나오는데 그게 계산기가 가지고 있는 메소드(함수)임.
계산기를 만들기 위해서는 변수를 최소 3개 이상 만들어야 한다.
저장된 숫자, 화면의 보이는, 숫자 연산자
스택은 두개
숫자에 대한 스택 오퍼레이트 스택

-------------------------------------

0.001234
12.34567    1234567 x E-5 과학기술표준법 10의 5승을 나누는 것.
123.4567    1234567 x E-4
1234.567    1234567 x E-3 

실수보다 정수를 다루는게 빠름.

Key 1, Key2, Key3, Key., Key4, Key5, Key6, Key7

(E가 exp임)
1 -> 1, E= -1 =>1
2 -> 12, E= -1 =>2
3 -> 123, E= -1 =>3
.  -> 1, E= 0 => 123 x E0 //점이 있는지 없는지 점이 없었을 때는 -1 점은 0 점 뒤부터는 1부터 카운트
4 -> 1234, E= 1 => 1234 x E-1
5 -> 12345, E= 2 => 123 x E-2
6 -> 123456, E= 3
7 -> 1234567, E= 4


12345 + 12345 [+, _, *, /, =] 이 앞에께 연산이 되야함.
12345 [+, _, *, /] 12345 [+, _, *, /, =]를 누르면 앞에 연산자가 있어야 함.

2-2.
12 + 75 + ->+가 올 때 마다 저장 현재 디스플레이가 되는 값을 스택에 저장 지금은 2개 저장됨

OPERAND STACK : [12, 78]
OPERATOR STACK: [+] 스택이 두개임

12 + 75 = 87

OPERAND STACK : [87] ->답이 나온 다음에는 이렇게 되야함
OPERATOR STACK: []

=================================

Stack  A: []// 숫자(오퍼랜드) 를 저장함
Stack  B: []// 연산자(오퍼랜드) 를 저장함

1234
+

Stack  A: [1234]// 숫자(오퍼랜드) 를 저장함
Stack  B: ['+']// 연산자(오퍼랜드) 를 저장함

12
=

Stack  A: [1234 , 12]// 숫자(오퍼랜드) 를 저장함
Stack  B: ['+']// 연산자(오퍼랜드) 를 저장함 (연산자를 확인하고 연산자와 숫자를 확인함)

1234 + 12

List<Double> operands = new ArryList<Double>();
List<Character>(List<KeyPad>) operands = new ArryList<Character>();


===================================
(스택계산이 아님. UI 계산기임. 그래서 예외처리(UI시나리오)까지 해줘야 함.)

디스플레이의 상태: 편집상태, 결과를 보여주는 상태

대입연산자 '='를 입력하면, 최근에 입력된 값이 오른쪽 오퍼랜드로 재사용된다.
ex) 2+5 하고 '='을 누르면 5가 마지막 값이기 때문에 '=' 만 계속 누르면 5더한값이 계속 나옴

대입연산자를 제외한 다른 연산자를 입력하여 계산을 했을 경우 => 사칙연산자
(이미 이항 연산자가 있는 경우))
연산의 결과가 최근의 입력된 값이 된다.
ex) 2+5 하고 '+'를 누르면 7이라고 자동 계산되고 그 상태에서 계속 '+'를 누르면 7더한값이 나옴

===================================

이전 연산자: null //숫자로만 되어있음 연산자 아무것도 없음.
현재 연산자: '=','+', '/', '-', '*'
-> 현재 편집중인 숫자를 저장

이전 연산자: '+', '/', '-', '*'//빼기랑 나누기는 교환법칙 성립 안됨. 그래서 순서가 중요함.
현재 연산자: '='
-> 현재 결과에 최근 입력값(우측 오퍼랜드)를 연산한다. 
-> 우측 오퍼랜드 변경 안됨
-> 이전 연산자 변경 안됨

이전 연산자: '+', '/', '-', '*'
현재 연산자: '+', '/', '-', '*' //우측 오펀랜드 값이 변경됨. 결과값으로 계속 똑같은 연산만 반복한다.
-> 이전 연산자의 결과가 현재 결과 저장되고,
-> 우측 오퍼랜드는 결과값으로 변경
->이전 연산자 변경 안됨


------------------------------------------------

다형성 상속성 은닉성
싱글턴은 설명할 수 있고 구현할 수 있고
생성자는 무엇? 멤버를 이니셜라이징, 객체의 상태를 초기화 할때
가베지컬렉터: 메모리상에 있는 사용이 끝난 오브젝트를 자동적으로
파기하여 메모리를 다시 이용할 수 있도록 해줌. 오브젝트명 = null로 해두면 알아서 회수함.
파이널라이즈(소멸자): 인스턴스가 소멸되기 직전에 자바 가상머신에 의해서 자동으로 호출되는 메소드.
자바의 소멸자가 없는 이유

기본적으로 실행 내용이 없음. 객체가 소멸되기 전에 마지막으로 사용했던 
자원(데이터 연결, 파일 등)을 닫고 싶거나 중요한 데이터를 저장하고 싶다면 
Object의 finalize()를 재정의할 수 있음. 
프로그램이 종료될 때 즉시 자원을 해제하거나 데이터를 최종 저장해야 한다면 프로그램이 
종료될 때 명시적으로 메서드를 호출하는 것이 좋음.


계산 주석 달아보기...ㅎ