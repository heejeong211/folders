-static 정적변수 클래스변수 공유변수
Method Area에 한번만 올려 초기화 한다.
클래스 내에서 어디든 불러와서 사용할 수 있다.

-함수는 무조건 call stack에 쌓인다.

-객체들이 static 변수를 공유하고 있기 때문에 instNum++ 때문에 숫자가 하나씩
증가하는 것임.

-클래스변수의 접근방법
클래스 내부 접근
static 변수가 선언된 클래스 내에서는 이름만으로 직접 접근 가능.
클래스 외부 접근
private으로 선언되지 않으면 클래스 외부에서도 접근 가능
접근 수준 지시자가 허용하는 범위에서 접근 가능
클래스 또는 인스턴스(객체)의 이름을 통해 접근
->클래스명으로 접근하는 것이 가장 좋은 방법

-static하자마자 초기화 시켜주는 것이 제일 좋음.
클래스 변수는 생성자 기본 초기화하면 안된다.
이 경우 인스턴스 생성시마다 값이 리셋!

-인스턴스 별로 가지고 있을 필요가 없는 변수
값의 참조가 목적인 변수
값의 공유가 목적인 변수

그리고 그 값이 외부에서도 참조하는 값이라면 public으로 선언한다.

-Math.PI
클래스명.변수명
PI가 static이라 Math 클래스에 접근 가능

-인스턴스변수
객체생성될 때 해당 메모리방을 잡기 때문에

-static 메소드 (클래스 메소드)
클래스명으로 다이렉트로 접근할 수 있음.

-인스턴스 메소드
객체생성해서 객체로 접근해야 한다.

-어떤것을 static으로 만들까?
기본적으로 많이 쓰는 것은 static으로 쓴다.
System.out.println();
여기서 System은 클래스임.
인스턴스변수와 관련없는 것. 바로 결과값이 나오는 것. 수학적인 것들.

-단순 기능 제공이 목적인 메소드들, 인스턴스 변수와 관련 지을 이유가
없는 메소드들은 static으로 선언하는 것이 옳다.

-클래스 메소드에서 인스턴스 변수에 접근이 가능할까?
static 함수 안에 인스턴스멤버(변수, 함수)가 올 수 없는 이유는?
static 함수 안에서 인스턴스 라면이 올 수 없는 이유는?
인스턴스 함수 안에는 인스턴스든 static이든 다 올 수 있음. 
그러나 static 함수 안에는 static 붙은 애들만 와야함.
인스턴스는 new 했을 때(객체생성)만 호출할 수 있음.
메모리 올라가는 시간이 다른기 때문. static은 클래스를 읽어들일 때
메모리에 올라가고 인스턴스는 new를 읽어들일 때 메모리에 올라간다.

-System.out.println();
원래는 System은 java.lang 패키지 안에 들어가있는 애.
그래서 import 써줘야하는데... 컴파일러가 알아서 해줌.

out의 의미는 뭘까?
out라는 참조형 변수 앞에 static이 붙음. 얘네가 System이라는 클래스 안에 있다.
그래서 System.out임.

println은 static이기 때문에 클래스를 직접적으로 불러올 수 있다.

-main 메소드가 public이고 static인 이유는?
JVM이 main을 실행.
JVM과 main이 같은 패키지라고 단정지울 수 없어서 public을 붙이는 거임.

-JVM은 누가 호출?
javac Hello.java
java Hello -> 이때 Hello.class파일을 열기 전에 JVM 호출.

-static 초기화 블록
참조형 변수는 초기화 하지 않으면 null이다.
한줄짜리 초기화면 바로 써주면 되는데,
몇줄에 거쳐서 초기화해줄 내용이 많은 경우에는 
static으로 묶어서 사용하면 됨. 단 그 변수도 앞에 static이 붙어있어야 됨.

---------------------------------------------------------
-오버로딩과 오버라이딩의 차이

-메소드 오버로딩이란?
우리가 자주쓰는 System.out.println();이다.
함수 이름이 같게 되면 구분을 못하기 때문에 구분지을 무언가가 있어야 컴파일을 할 수 있음.
메소드 이름이 같은 때는 인자의 개수를 따진다.
인자 개수까지 똑같으면 해당 인자의 데이터타입을 따진다.
메소드 오버라이딩은
같은 함수의 이름으로 인자의 타입 내지는 개수를 달리하거나 타입을 달리하는 것. 

반환형은 메소드 오버로딩의 조건이 아님.

-매개변수 = 파라미터 = 인자??

-생성자 또한 메소드 오버로딩 할 수 있음.
생성자도 메소드이기 때문.

-this란
객체 자기 자신을 나타냄.
용도는
1. 자기 자신의 변수를 나타낼 때
2. 함수 처럼 만드는 것. this 함수는 자기 자신이기 때문에 자기 자신의 생성자를 호출 하는 것임. => 생성자 함수

-println();
println 함수는 데이터 타입이 뭐든 다 받아낼 수 있다.
println 함수는 메소드 오버로딩을 사용해서 하나하나 만들어 졌기 때문에 데이터 타입이 뭐든
다 받아낼 수 있는 것이다.

-String
1. String str1 = new String("Simple String"); ->객체생성
2. String str2 = "Simple String";
1, 2가 다름 -> 1은 객체를 만드는 거고, 2는 Simple String을 
주소로(상수처럼 만들어서) 만들어서 가지고 있는 거다.

-Method Area안에는 Constant Pool이라는 곳에서 문자열을 저장함.

-진짜 들어가 있는 문자열을 비교할 때
if(str1.equals(str2)) -> equals를 사용함.

-String 인스턴스는 Immutable(불변, 변할 수 없는) 인스턴스다.

-String은 비용이 든다.
비용이 든다 -> 메모리 많이 사용하고 시간 많이 사용하는 것.

-String -> 캐릭터의 배열, 마지막 문자에는 null을 넣음.

-Immutable
해당 클래스 내에 있는 변수의 벨뉴값을 못바꾸게 하는 것.
그래서 만약 벨뉴값을 바꾸고 싶다면 전꺼는 복사해서 새로 하나 만들어야 한다.
-> 그래서 비용이 많이 듦.

-String은 new해서 생성하는 것은 별로 안좋은 방법.

-예전에 swich문은 괄호에 int밖에 못들어 갔는데 요즘은 String도 들어감.
String이 주소값을 가지고 있고 그 주소값이 4바이트이기 때문에 swich에
String이 들어감.

-concat 붙이는 거.
concat의 리턴타입은 String이다.

-배열의 특징
무조건 연속된 공간. 만약에 5개글자면 2x5 10개의 연속된 공간을 만든다.
배열은 0번째부터.

-compareTo 사전으로 비교. (영어)사전에 누가 먼저 앞에 나오게되는지... 1,0,-1

-compareToIgnoreCase case를 무시해라 -> 대소문자를 무시해라.

-모르는 함수 나왔을 때
함수 옆에 F3누르기
아니면 인터넷 찾기
아니면 오라클 페이지 들어가서 보기 oracle java 8 documentation (API)

-기본 자료형의 값을 문자열로 바꾸기
.valueOf() -> 어떤 기본 자료형이든 리턴값이 문자열이다. 숫자를 문자로 바꾸고 싶을 때.

-System.out.println("funny" + "camp"); - > System.out.println("funny".concat("camp")); 
컴파일러에 의한 자동 변환.

-문자열과 숫자가 같이 오면 문자열로 바꾼다.
String str = "age: " + 17; - > String str = "age: ".concat(String.valueof(17)); 

-concat메소드는 이어서 호출 가능

-왜 Immutable(불변)을 해야하는가?
배열을 OS가 이 배열 끝에 게임이 쓰고 있을지 뭘 쓰고 있을지 모르니까 
아에 새로운 영역을 찾아서 그 영역으로 줘야하기 때문.

-StringBuilder append(); -> 문자열을 붙이는 거. (양이 많을 때)
하고 나서 toString(); 해서 문자열로 바꾸어준다.

-StringBuilder vs String
붙이고 자르고 교체해야 하는 일이 많을 때(버퍼에 채우는 형식) -> StringBuilder 사용
그 이외의 모든 일(다시 복사를 한다음에 새로운 주소를 만들어야 함) -> String 사용

-StringBuffer 
쓰레드에 안전하다.

-----------------------------------------------
어제자...

1. 클래스와 객체에 대하여 설명하시오.
.class는 32비트짜리 명령어 덩어리이다. JVM이 알아먹기 위해.
new했을 때 동적할당이 일어나면서 heap에 저장되는데 그것을 객체라고 한다.
.class가 메모리에 올려진 상태에서 해당 변수에 heap에 할당된 메모리의 첫번째 주소를 객체라고 표현함.

2. -classpath와 상대경로 절대경로에 대하여 설명하시오.
-classpath는 JVM이 .class가 있는 해당 경로를 알려줄 때,
절대경로 루트(C:, D:, E:)부터 표현되는거, 상대경로 현재폴더를 기준으로 경로를 표현하는 것.

3. 생성자에 대하여 설명하시오.
생성자는 함수이다. 
함수의 특징: 클래스 이름과 같다. 리턴타입이 없다. 
생성자 용도: 객체 생성할 때 불리는 함수. 변수 초기화.
함수 오버로딩을 통해 여러개를 생성할 수 있다.

4. 자바에서 패키지(물리적, 공간적인 요소 포함)에 대하여 설명하시오.
같은 이름의 클래스를 main에서 사용해야 하는데 그 때 패키지를 이용한다.
물리적: 같은 이름의 클래스들을 패키지로 다르게 줄 수 있다.
공간적: main에서 같은 이름의 클래스들을 사용할 수 있다.

------------------------------------------------
면접

1.접근제한자 4가지에 대하여 설명하고 접근제한범위에 대하여 설명하시오.
public defualt protected private
public: 어디서든 접근 가능
defualt: 같은 패키지 내에서만 접근 가능
protected: 같은 패키지, 같은 클래스 내에서만 접근 가능한데 상속받은 곳에서도 접근 가능함.
private: 해당 클래스 내에서만 접근 가능

2.인스턴스 함수에 정적 함수 또는 변수 가 올 수 없는 이유는?
올 수 있다.
그러나 정적 함수에 인스턴스 함수 또는 변수가 올 수 없다.
그 이유는 정적 함수는 클래스를 읽을 때 클래스를 Method Area에 저장하고나서 정적 함수를 Method Area
에 저장하고 그 이후에 인스턴스 함수 또는 변수를 읽는 데, new 연산자를 사용해서 객체를 만들어 Heap에 
저장하기 때문에 순서가 다르기 때문에 인스턴스 함수 또는 변수가 정적 함수에 올 수 없다.

3.문자열 생성 방법 2가지에 대하여 설명하고 차이는 무엇인가요?
하나는 new 연산자를 사용해서 파라미터에 문자열을 입력해서 객체를 만드는 방법이고, 
하나는 참조형 변수에 큰다옴표를 이용해서 직접 문자열을 입력하는 방식이다.
new연산자를 사용한 방식은 객체의 주소를 가져오는 것이고, 직접 문자열을 입력하는 방식은 문자열을 유니코드로
바꾸어서 그 유니코드를 주소로 만든 것이다.

4.메소드 오버로딩이란 무엇인가?
같은 이름을 가졌으나 함수의 인자 또는 순서, 타입이 다른 것을 여러 개로 정의한 것을 말한다.

5.Method  area, call stack, heap  영역에 대하여 설명하시오.
java 명령어를 통해 .class 를 실행할 때 JVM은 해당 클래스를
Method area 에는 클래스와 static 메소드가 들어가고
call stack 에는 main함수가 들어가고
heap에는 new 연산자를 사용한 객체와 인스턴스 함수가 들어간다. 

6.string 객체가 불변인 이유는 무엇인가?
어떤 데이터가 메모리에 저장되어있지 모르기 때문에.
OS가 배열을 관리하는데, 그 배열 끝에 게임이 쓰고 있을지 뭘 쓰고 있을지 모르니까 
아에 새로운 영역을 찾아서 그 영역으로 줘야하기 때문.

7.String 과 StringBuilder의 차이는 무엇인가?
붙이고 자르고 교체해야 하는 일이 많을 때(버퍼에 채우는 형식) -> StringBuilder 사용
그 이외의 모든 일(다시 복사를 한다음에 새로운 주소를 만들어야 함) -> String 사용